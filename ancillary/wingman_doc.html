<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Wingman Documentation</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="custom.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Wingman Documentation</h1>
</header>
<h1 id="wingman---behind-the-veil">Wingman - Behind the Veil</h1>
<p>This document serves as a guide to understanding the program’s
functionality and the process for making edits to its source code.</p>
<h2 id="user-journey">User Journey</h2>
<pre class="mermaid"><code>flowchart TB
    A[Bookmarklet] --&gt; D[Initialize]
    D --&gt; I{&quot;`USER INPUT:
Asks for an instruction`&quot;}
    I -- User selects &#39;quit&#39; --&gt; K[Exit Program]
    I --No valid input--&gt; M[Error - Try again]
    M --&gt; D
    I -- User selects a valid scenario --&gt; L[&quot;`USER INPUT: 
Asks for a clue to make the PR and escalation`&quot;]
    L --&gt; N[Handle Scenario Logic]
    N --&gt; O[Terminal output + Clipboard ]
    O --&gt; P{&quot;`USER INPUT: 
Waits for user...`&quot;}
    P -- User continues --&gt; J
    I -- User selects &#39;restart&#39; --&gt; J[Restart Program]
    P -- User quits --&gt; K
    J --&gt; D
</code></pre>
<h2 id="forms---scenarios">Forms - Scenarios</h2>
<p>The program generates the DS by remixing the elements that make up a
DS which are stored in an <code>elements</code> dictionary. For example
<code>---</code> denotes a divider. Anything that can occur in the DS on
a separate line is defined separately in elements, and then used to
define the forms. The mutable configuration allows for post processing
by intentions down the line. Here are the basic scenario forms that are
precoded by hand: 1. <code>l1</code> - Send to L1 2. <code>cst</code> -
Send to customer 3. <code>exsc</code> - Send to external team (via Side
Conversation) 4. <code>exold</code> - Send to external team (place back
on hold - in escalation) 5. <code>ex</code> - Send to external team
(generic - not used) 6. <code>exjira</code> - Send to external team (via
a Jira) 7. <code>exeng</code> - Send to external team (Engineering) 8.
<code>exb</code> - Elevate to BU 9. <code>l2</code> - Send to L2 10.
<code>clst</code> - Close ticket 11. <code>clsch</code> - Close chat 12.
<code>sum</code> - Summarize chat</p>
<p>The code is also what prints to screen in front of the ‘Form:’. There
are more forms that are generated dynamically such as <code>no_pr</code>
scenario forms which have an ‘n’ appended to them, for example,
<code>cstn</code> for a form that excludes the PR, but generates the
rest of the DS elements.</p>
<h2 id="intents">Intents</h2>
<p>Apologies for the confusion. Here’s the complete table with the
remaining intents and their corresponding outcomes:</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 21%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th>Intent</th>
<th>Intent Name</th>
<th>Outcomes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>no_esc</td>
<td>No Escalation</td>
<td>Includes all outcomes except escalation ones:<br> exjira, exjiran,
exsc, exscn</td>
</tr>
<tr class="even">
<td>yes_pr</td>
<td>Yes - PR Required</td>
<td>Includes all outcomes except clsch - Close chat</td>
</tr>
<tr class="odd">
<td>no_pr</td>
<td>No - PR Not Required</td>
<td>Includes all form outcomes that end with n (without PR)</td>
</tr>
<tr class="even">
<td>sum</td>
<td>Summarize Chat</td>
<td>sum - Summarize chat</td>
</tr>
<tr class="odd">
<td>vp</td>
<td>Vendor Partner</td>
<td>exsc - Send to external team (via Side Conversation)<br>exscn - Send
to external team (via Side Conversation, without PR)</td>
</tr>
<tr class="even">
<td>cf</td>
<td>Central Finance</td>
<td>exjira - Send to external team (via a Jira)<br>exjiran - Send to
external team (via a Jira, without PR)</td>
</tr>
<tr class="odd">
<td>sc</td>
<td>Side Conversation</td>
<td>exsc - Send to external team (via Side Conversation)<br>exscn - Send
to external team (via Side Conversation, without PR)</td>
</tr>
<tr class="even">
<td>bz</td>
<td>Business Unit</td>
<td>exjira - Send to external team (via a Jira)<br>exjiran - Send to
external team (via a Jira, without PR)</td>
</tr>
<tr class="odd">
<td>acc_mgt</td>
<td>Account Management</td>
<td>exsc - Send to external team (via Side Conversation)<br>exscn - Send
to external team (via Side Conversation, without PR)<br>exjira - Send to
external team (via a Jira)<br>exjiran - Send to external team (via a
Jira, without PR)</td>
</tr>
<tr class="even">
<td>eng</td>
<td>Engineering</td>
<td>exeng - Send to external team (Engineering)<br>exengn - Send to
external team (Engineering, without PR)</td>
</tr>
<tr class="odd">
<td>bu</td>
<td>Business Unit</td>
<td>exb - Elevate to BU<br>exbn - Elevate to BU (without PR)</td>
</tr>
<tr class="even">
<td>force_esc</td>
<td>Force Escalation</td>
<td>Includes all outcomes except exb and exbn</td>
</tr>
<tr class="odd">
<td>force_elevate</td>
<td>Force Elevate</td>
<td>Includes all outcomes except exsc, exscn, exjira, exjiran</td>
</tr>
<tr class="even">
<td>chat</td>
<td>Chat</td>
<td>clsch - Close chat</td>
</tr>
<tr class="odd">
<td>clst</td>
<td>Close Ticket</td>
<td>clst - Close ticket<br>clstn - Close ticket (without PR)</td>
</tr>
<tr class="even">
<td>in_esc_update</td>
<td>In Escalation - Update</td>
<td>exold - Send to external team (place back on hold - in
escalation)<br>exoldn - Send to external team ( in escalation, without
PR)</td>
</tr>
<tr class="odd">
<td>JIRA(names)</td>
<td>JIRA keys</td>
<td>Every JIRA name is loaded into the intent sets with the jira key for
example IGBIZOPS, STREETSMART etc. are all
intents.<br>Scenarios:<br>exjira - Send to external team (via a
Jira)<br>exjiran - Send to external team (via a Jira, without PR)</td>
</tr>
</tbody>
</table>
<h2 id="functionality-and-source-code-editing-guide">Functionality and
Source Code Editing Guide</h2>
<p><strong>1. Term Search</strong></p>
<p>The program looks for search terms to confirm if an intent exists. It
is designed to favor larger terms under the assumption that they are
more specific. This process is defined under the function
<code>encapsulation_check</code>.</p>
<p><strong>2. Negation Handling</strong></p>
<p>The program is built to ignore negated terms. For instance, the term
“don’t write” should not be parsed as “write” just because there is a
search term match and the <code>negation_check</code> seems to do a good
job of excluding all of these hits. This is crucial to avoid creating
null sets in the subsequent Venn diagram.</p>
<p>However, there is currently no universal logic for intiuting a
negative intention from a negation i.e. don’t write will not be parsed
as write but it also won’t automatically exclude the “Yes, send a PR”
intent allowing for matches to happen in the rest of the instruction.
The don’t send a PR intent is manually incorporates this logic however
initializing a contrasting set of search terms by expanding the ‘Yes’
set with appended negations. A similar thing is at play in ‘no_esc’.</p>
<p><em>Note:</em> The benefit of parsing an automatic negative intention
as a negative intent could be worth considering as it could make the
program scalable and the Venn sets tighther with just a single line of
code. While this would simplify the logic and provide consistency across
intentions, we would need to consider the potential implications in
terms of unintended consequences. Feedback needed before implementing
this change.</p>
<p><strong>3. Intent Popping Overrides</strong></p>
<p>These are manually defined to instruct the program that certain
options cannot coexist. For example, if the intention is to send a Side
Conversation, there is no need to consider ‘jira_generic’, and thus,
that intent is removed.</p>
<p><strong>4. Venn Diagram Creation</strong></p>
<p>The program creates a Venn diagram of the options and checks if only
a single possibility remains. If more than two possibilities exist, the
program applies a default behavior logic.</p>
<p><strong>5. Form Selection</strong></p>
<p>The program isolates a specific form.</p>
<p><strong>6. Intent Value Writing</strong></p>
<p>The selected intentions write their respective values to the
forms.</p>
<p><strong>7. OpenAI API Call</strong></p>
<p>The program makes an API call to OpenAI to populate the PR.</p>
<p><strong>8. Escalation Text Fetching</strong></p>
<p>Depending on the intention type (escalation or not), the program
decides whether to fetch the Escalation text from OpenAI.</p>
<p><strong>9. Post-Processing</strong></p>
<p>The program performs post-processing of the form in the list
popper.</p>
<p><strong>10. Copy to Clipboard</strong></p>
<p>Finally, the processed form is copied to the clipboard for further
use.</p>
<h2 id="flow-to-expand-the-program">Flow to Expand the Program</h2>
<ol type="1">
<li><p><strong>Search Terms:</strong> Define search terms and assign
them a key. Decide if you want partial match or full match. Denote with
<code>searchterm%</code>, <code>searchterm</code>,
<code>%searchterm%</code>, or <code>%searchterm</code>.</p></li>
<li><p><strong>Possible Forms:</strong> Define the possible forms
associated with this intent. For example, the set associated with intent
<code>send to</code> includes <code>l2</code>, <code>l1</code>,
<code>jira</code>, <code>sc</code> but not
<code>send to customer</code>, <code>close ticket</code> or
<code>close chat</code>. For <code>vp</code> it only includes one option
<code>sideconversation</code>.</p></li>
<li><p><strong>Escalation Intent:</strong> If it’s an escalation intent,
look at the search terms in the <code>esc</code> set and decide if this
should separately be added to the <code>esc</code> set as a search term.
This is not necessary if intent will always occur together with regular
escalation words like <code>escalate to</code> or
<code>send to</code>.</p></li>
<li><p><strong>No PR Intent:</strong> If it’s a <code>no pr</code>
intent, add it to the <code>no_pr</code> set.</p></li>
<li><p><strong>No ESC Intent:</strong> If it’s a <code>no_esc</code>
intent, don’t make an escalation even though it seems from the wording
you should.</p></li>
<li><p><strong>Opposite Intent:</strong> Define opposite intent and
expand it with negations. This won’t have to be a step if we decide to
apply the expansion across the board.</p></li>
<li><p><strong>Overrides:</strong> Define overrides, consider if this
intent should be overridden by others if occurring / found together with
them and add it to their override set. These are the non-sensical
options intuited from search terms but actually can’t happen together in
the real world.</p></li>
<li><p><strong>Default Behavior:</strong> Define default behavior if
any. Should this be excluded or be the default in case of
conflict?</p></li>
<li><p><strong>Form Filling Options:</strong> Define the form filling
options in mapping one to one. Remember, higher overrides lower. The
program prints conflicts to screen.</p></li>
<li><p><strong>Form Changes:</strong> Define if any changes need to
happen to the form in <code>list_popper</code> which also does
insertions. For example, if any part of the form should be included or
excluded. You will find that <code>PR</code> elements the
<code>divider</code>, <code>pr_label</code>, and the <code>pr</code> are
removed in the <code>no_pr</code> intent to output the form without
these elements. Note that forms are built up from “elements” like
<code>pr_label</code>, <code>additional_context_label</code>,
<code>divider</code> etc defined in the elements dictionary. These
elements get remixed by <code>remixer</code> into the final output
<code>DS</code>.</p></li>
</ol>
<h2
id="short-flow-to-add-a-simple-intent-that-can-write-to-a-form-field">Short
Flow to Add a Simple Intent that Can Write to a Form Field</h2>
<ol type="1">
<li><p><strong>Search Terms:</strong> Define search terms and assign
them a key. Decide if you want partial match or full match. Denote with
<code>searchterm%</code>, <code>searchterm</code>,
<code>%searchterm%</code>, or <code>%searchterm</code>.</p></li>
<li><p><strong>Possible Forms:</strong> Define the possible forms
associated with this intent. For example, <code>UDF</code> intent has
only <code>escalate via jira</code> as a possibility.</p></li>
<li><p><strong>Overrides (Optional):</strong> If search terms are too
generic and you think will hit other intentions, define overrides.
Consider if this intent should be overridden by others if occurring /
found together with them and add it to their override set. These are the
non-sensical options intuited from search terms but actually can’t
happen together in the real world. For example, <code>Udf</code> not to
worry, but if the unit type was <code>acc</code> you would want to put
up overrides to exclude everything but <code>acc</code> otherwise this
wouldn’t fire in the final venn.</p></li>
<li><p><strong>Form Filling Options:</strong> Define the form filling
options in mapping one to one.</p></li>
</ol>
<h1 id="function-reference">Function Reference</h1>
<ul>
<li><code>get_resource_path()</code>: Determines the path where the
script is running, defaulting to the config bundled with the executable
if necessary.</li>
<li><code>term_print_string(string, indent)</code>: Wraps and indents a
given string for terminal output, respecting the terminal width.</li>
<li><code>print_bright(message, color_code)</code>: Prints a message to
the terminal using a specified ANSI color code for bright colors.</li>
<li><code>print_wrapped(string, color)</code>: Wraps a given string to
the terminal width and prints it with the specified color.</li>
<li><code>print_logo()</code>: Prints a logo and version information to
the terminal with styling.</li>
<li><code>clear_terminal()</code>: Clears the terminal screen based on
the operating system.</li>
<li><code>set_terminal_size(rows, columns)</code>: Sets the terminal
window size to specified rows and columns.</li>
<li><code>preserve_newlines(tag)</code>: Extracts text from an HTML tag,
preserving line breaks and formatting.</li>
<li><code>firstpr_extractor(soup)</code>: Extracts the first public
response from a BeautifulSoup object representing a Zendesk ticket.</li>
<li><code>get_ticket_number(ticket_soup)</code>: Extracts the ticket
number from a BeautifulSoup object representing a Zendesk ticket.</li>
<li><code>get_product(soup)</code>: Extracts the product name from a
BeautifulSoup object representing a Zendesk ticket.</li>
<li><code>scenario_extractor(instruction_string)</code>: Processes an
instruction string to determine the user’s intent and applicable
scenario.</li>
<li><code>bylinestripper(string)</code>: Removes signature lines from a
given string, typically from email or support ticket responses.</li>
<li><code>ds_printer(finalstring)</code>: Prints the final output string
to the terminal with decorative styling.</li>
<li><code>jira_link_stripper(string)</code>: Removes JIRA link
placeholders from a given string.</li>
<li><code>bu_elevation_stripper(string)</code>: Replaces a specific HTML
table structure with a plain text equivalent in a given string.</li>
<li><code>get_zd_messages(soup, f_pr)</code>: Extracts and formats
Zendesk messages from a BeautifulSoup object.</li>
<li><code>get_intuitPR(model_input, conversation, preseeded_context, seededclue, pr_promptsys, pr_prompt1, pr_prompt2)</code>:
Generates a public response using the OpenAI model based on a
conversation and clues.</li>
<li><code>get_intuitIssue(model_input, conversation, response, pr_promptsys)</code>:
Summarizes a customer issue in a single line or short paragraph using
the OpenAI model.</li>
<li><code>get_intuitEsc(model_input, conversation, response, dictname, clue, pr_promptsys, pr_prompt1, pr_prompt2, pr_prompt3)</code>:
Generates an escalation message using the OpenAI model based on a
conversation, response, and clues.</li>
<li><code>get_name_from_file(dir_path)</code>: Reads the agent’s name
from a text file in the program directory.</li>
<li><code>get_gpt_from_file(use_case, dir_path, default_gpt_model)</code>:
Reads the GPT model configuration from a text file in the program
directory.</li>
<li><code>get_bu_esc_datatable(product, thedict)</code>: Creates a rich
text table for escalation to the Business Unit (BU) based on a product
name and a dictionary of elements.</li>
<li><code>dict_writer(orig_intent_list, global_intents_list, dict_to_update)</code>:
Writes to a dictionary based on intent lists and updates it with
specific values.</li>
<li><code>remix_elements(orig_form, dict_of_elements)</code>: Combines
elements from a form template and a dictionary to create a string
output.</li>
<li><code>link_updater(productname, intent_list, dict_of_elements)</code>:
Updates links in a dictionary of elements based on the product name and
intent list.</li>
<li><code>list_popper(orig_intent_list, orig_list_to_pop)</code>:
Filters a list of form elements based on the intent list, removing or
adding elements as needed.</li>
<li><code>modify_string(string, scenario, prodname)</code>: Customizes a
string with scenario-specific modifications and product name
insertion.</li>
<li><code>main()</code>: The main function that orchestrates the
script’s execution flow, including user interaction and processing
logic.</li>
</ul>
<pre class="mermaid"><code>flowchart TD
    A[Start] --&gt; B(Print Logo)
    B -- Yes --&gt; G(Parse HTML Content)
    G --&gt; I[Extract First Message]
    I --&gt; J[Extract Zendesk PR Messages]
    J --&gt; Ja{First same as PRs?}
    Ja -- Yes --&gt; K[Define Byline]
    Ja -- No --&gt; Ka[Append first IN on top of messages]
    Ka --&gt; K
    K --&gt; M[&quot;`Get User Input:
    Instruction!`&quot;]
    M --&gt; M1[&quot;`Subgrpah: 
    Handle Form Scenario`&quot;]
    M --&gt; N{Is Chosen Scenario Restart?}
    N -- Yes --&gt; O[Restart Program]
    N -- No --&gt; P{Is Chosen Scenario Quit?}
    P -- Yes --&gt; Q[Exit Program]
    P -- No --&gt; R{Is Chosen Scenario in Forms?}
    R -- Yes --&gt; S[Handle Form Scenario]
    R -- No --&gt; T[Print Undefined Scenario Error]
    T ---&gt; M
    S --&gt; U[Get Ticket Product and Number from html]
    U --&gt; V{Does Scenario Require PR?}
    V -- Yes --&gt; W[&quot;`Make a prompt with standard prompt
    Add Conversation 
    Add the clue`&quot;]
    V -- No --&gt; X{Does Scenario Require Escalation?}
    W1 --&gt; X
    X -- Yes --&gt; Y1[Handle Escalation Scenario]
    X -- No --&gt; Z[Update Links and Write to Dict]
    Y1 --&gt; Z1
    Z --&gt; AA[Populate and Modify Form]
    AA --&gt; AB[Print and Copy Final String]
    AB --&gt; AC[Handle Bookmarklet Input]
    AC --&gt; AD{Is Last Input Quit?}
    AD -- Yes --&gt; Q
    AD -- No --&gt; O

    subgraph Restart Program [Restart Program]
        O[Clear Terminal] --&gt; A
    end

    subgraph Exit Program [Exit Program]
        Q[Print Goodbye Message] --&gt; Q1[System Exit]
    end

    subgraph &quot;Handle Form Scenario&quot;
        S1[Get Information from User] --&gt; Sx1
        S2 -- Yes --&gt; O
        S2 -- No --&gt; S3{Is Information a Quit Command?}
        S3 -- Yes --&gt; Q
        S3 -- No --&gt; S
        Sx1[Parse Intents] --&gt; Sx2[Overrides]
        Sx2 --&gt; Sx4[Apply Scenario Extractor]
                        
        Sx4 --&gt;  Sx3{Is there only one scenario?} -- Yes --&gt; S2{Is Information a Restart intent?}
        Sx3 -- No --&gt; Sx5[Heuristic - Min Set] --&gt; S
    end
    subgraph Handle PR Scenario 
       W --&gt; W1[Get PR Response] 
    end

    subgraph Handle Escalation Scenario [Handle Escalation Scenario]
        Y[Get Escalation from OpenAI] --&gt; Y1 
    end

    subgraph Update Links and Write to Dict [Update Links and Write to Dict]
        Z1[JIRA Link Updater] --&gt; Z2[&quot;`Dict Writer based
        on Intents parsed`&quot;] --&gt; Z
    end

    subgraph Populate and Modify Form [Populate and Modify Form]
        AA1[List Popper] --&gt; AA2[Remix Elements] --&gt; AA3[Modify String] --&gt; AA
    end

    subgraph Print and Copy Final String [Print and Copy Final String]
        AB --&gt; AB1[DS Printer] --&gt; AB2[Copy to Clipboard]
    end

    subgraph Handle Bookmarklet Input [Handle Bookmarklet Input]
        AC1[Get Bookmarklet Input] --&gt; AC
    end</code></pre>
</body>
</html>
